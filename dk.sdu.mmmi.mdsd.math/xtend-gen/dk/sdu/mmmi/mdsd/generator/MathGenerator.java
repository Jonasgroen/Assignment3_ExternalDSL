/**
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator;

import dk.sdu.mmmi.mdsd.math.Binding;
import dk.sdu.mmmi.mdsd.math.Div;
import dk.sdu.mmmi.mdsd.math.LetBinding;
import dk.sdu.mmmi.mdsd.math.MathExp;
import dk.sdu.mmmi.mdsd.math.MathNumber;
import dk.sdu.mmmi.mdsd.math.Minus;
import dk.sdu.mmmi.mdsd.math.Mult;
import dk.sdu.mmmi.mdsd.math.Plus;
import dk.sdu.mmmi.mdsd.math.Power;
import dk.sdu.mmmi.mdsd.math.Program;
import dk.sdu.mmmi.mdsd.math.SquareRoot;
import dk.sdu.mmmi.mdsd.math.VarBinding;
import dk.sdu.mmmi.mdsd.math.VariableUse;
import java.util.Arrays;
import java.util.Map;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MathGenerator /* implements AbstractGenerator  */{
  private static Map<String, Integer> variables;
  
  public void doGenerate(final /* Resource */Object resource, final /* IFileSystemAccess2 */Object fsa, final /* IGeneratorContext */Object context) {
    throw new Error("Unresolved compilation problems:"
      + "\n+ cannot be resolved."
      + "\nallContents cannot be resolved"
      + "\ntoIterable cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nallContents cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nnext cannot be resolved"
      + "\ncompute cannot be resolved"
      + "\ngenerateFile cannot be resolved"
      + "\nprogram cannot be resolved"
      + "\n+ cannot be resolved"
      + "\ncompile cannot be resolved");
  }
  
  public CharSequence compile(final Program p) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\n!== cannot be resolved."
      + "\n== cannot be resolved."
      + "\n== cannot be resolved."
      + "\n== cannot be resolved.");
  }
  
  public void displayPanel(final Map<String, Integer> result) {
    throw new Error("Unresolved compilation problems:"
      + "\n+= cannot be resolved."
      + "\n+ cannot be resolved."
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static Map<String, Integer> compute(final MathExp math) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field variables is undefined for the type MathExp"
      + "\ncomputeExpression cannot be resolved");
  }
  
  protected static int _computeExpression(final VarBinding binding) {
    MathGenerator.variables.put(binding.getName(), Integer.valueOf(MathGenerator.computeExpression(binding.getExpression())));
    return (MathGenerator.variables.get(binding.getName())).intValue();
  }
  
  protected static int _computeExpression(final MathNumber exp) {
    return exp.getValue();
  }
  
  protected static int _computeExpression(final Plus exp) {
    throw new Error("Unresolved compilation problems:"
      + "\n+ cannot be resolved.");
  }
  
  protected static int _computeExpression(final Minus exp) {
    throw new Error("Unresolved compilation problems:"
      + "\n- cannot be resolved.");
  }
  
  protected static int _computeExpression(final Mult exp) {
    throw new Error("Unresolved compilation problems:"
      + "\n* cannot be resolved.");
  }
  
  protected static int _computeExpression(final Div exp) {
    throw new Error("Unresolved compilation problems:"
      + "\n/ cannot be resolved.");
  }
  
  protected static int _computeExpression(final LetBinding exp) {
    return MathGenerator.computeExpression(exp.getBody());
  }
  
  protected static int _computeExpression(final Power exp) {
    int _xblockexpression = (int) 0;
    {
      MathGenerator.computeExpression(exp.getN());
      _xblockexpression = MathGenerator.computeExpression(exp.getM());
    }
    return _xblockexpression;
  }
  
  protected static int _computeExpression(final SquareRoot exp) {
    return MathGenerator.computeExpression(exp.getN());
  }
  
  protected static int _computeExpression(final VariableUse exp) {
    return MathGenerator.computeBinding(exp.getRef());
  }
  
  protected static int _computeBinding(final VarBinding binding) {
    throw new Error("Unresolved compilation problems:"
      + "\n! cannot be resolved.");
  }
  
  protected static int _computeBinding(final LetBinding binding) {
    return MathGenerator.computeExpression(binding.getBinding());
  }
  
  public static int computeExpression(final Object exp) {
    if (exp instanceof Div) {
      return _computeExpression((Div)exp);
    } else if (exp instanceof LetBinding) {
      return _computeExpression((LetBinding)exp);
    } else if (exp instanceof MathNumber) {
      return _computeExpression((MathNumber)exp);
    } else if (exp instanceof Minus) {
      return _computeExpression((Minus)exp);
    } else if (exp instanceof Mult) {
      return _computeExpression((Mult)exp);
    } else if (exp instanceof Plus) {
      return _computeExpression((Plus)exp);
    } else if (exp instanceof Power) {
      return _computeExpression((Power)exp);
    } else if (exp instanceof SquareRoot) {
      return _computeExpression((SquareRoot)exp);
    } else if (exp instanceof VarBinding) {
      return _computeExpression((VarBinding)exp);
    } else if (exp instanceof VariableUse) {
      return _computeExpression((VariableUse)exp);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(exp).toString());
    }
  }
  
  public static int computeBinding(final Binding binding) {
    if (binding instanceof LetBinding) {
      return _computeBinding((LetBinding)binding);
    } else if (binding instanceof VarBinding) {
      return _computeBinding((VarBinding)binding);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(binding).toString());
    }
  }
}
